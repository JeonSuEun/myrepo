CH1-2 OSS License

SW 라이선스 
SW는 그것을 개발한 사람만(권리자)이 사용할 수 있지만, 권리자가 다른 사람에게 일정한 조건으로 특정 행위를 할 수 있는 권한을 부여할 수 있다.
이와 같은 권환을 '라이선스'라고 함

OSS 라이선스
오픈소스SW 개발자와 이용자 간에 이용 방법 및 조건의 범위를 명시한 계약
라이선시(Licensee) : 라이선스를 받는자 / 라이선서(Licenser) : 라이선스를 부여하는 자
라이선시는 라이선서가 규정한 라이선스를 지켜야 함
1. 라이선시는 해당 오픈소스SW를 자유롭게 이용할 수 있다. 2. 라이선시는 해당 오픈소스SW를 자유롭게 복제할 수 있으며, 일정한 조건하에 재배포할 수 있다.
3. 라이선시는 해당 오픈소스SW를 자유롭게 수정하여 이용할 수 있으며, 일정한 조건하에 수정된 내용을 재배포할 수 있다.
4. 라이선시는 해당 오픈소스SW의 소스코드를 자유롭게 획득하고 접근할 수 있다.
OSS 라이선스 규정을 제대로 지키지않으면 라이선서로부터 소송을 당할 수 있음

OSS라이선스 공통적 준수사항
저작권 관련 문구 유지 / 제품명 중복 방지(상표권으로 보호받기 떄문) / 서로 다른 라이선스의 조합(서로 다른 라이선스로 배포된 오픈소스SW를 결합하는 경우 반드시
두 개의 라이선스가 서로 호환되는지를 확인하여야 한다.)

OSS라이선스 선택적 준수사항
이용 여부 명(해당 오픈소스SW가 이용되었음을 명시) / 소스코드 공개(일부 변경한 OSS를 포함하는 SW배포(판매)하는 경우, 상당수 OSS 라이선스는 변경된 부분의 소스코드를 공개할 것을 요구)
/ 특허(특허기술을 OSS로 구현할 때 반드시 특허권자의 허락을 받아야 함)
                
                무료이용가능 / 배포허용가능 / 소스코드 취득가능 / 소스코드 수정가능 /2차적 저작물 재공개 의무 / 독점 SW와 결합가능 / 예시
           GPL       O              O               O               O                       O                   X            리눅스커널,WORDPRESS,GIT,마리아DB
          LGPL       O              O               O               O                       O                   O            파이어폭스(2.1)
           MIT       O              O               O               O                       X                   O            X WINDOWS,JQUERY,Angular.js
   BSD LICENSE       O              O               O               O                       X                   O            OpenCV, Nginx
APACHE LICENSE       O              O               O               O                       X                   O            Android, Hadoop

GPL(GNU General Public License)
GNU 프로젝트로 배포하는 소프트웨어에 적용하기 위해 FSF에서 작성 / 소스코드 공개에 대한 해석이 까다롭고 강력한 제한을 가짐 / GPL SW에 의해 파생된 SW는 그것의 전체
소스코드 또한 공개해야 함. 대표적인 SW: Linux Kernel, Git, Wordpress

GNU LGPL(Lesser General Public License)
LGPL OSS를 정적 또는 동적 라이브러리로 사용한 프로그램을 개발하여 배포할 경우에는 프로그램 소스코드를 공개하지 않아도 되며 LGPL OSS를 사용했다는 것만 명시하면 됨.

MIT License
MIT에서 학생들을 돕기 위해 개발한 라이선스. 라이선스와 저작권 관련 명시만 지켜주면 되는 라이선스로 가장 느슨한 조건을 가진 라이선스 중 하나임
BSD 라이선스를 기초로 작성된 BSD계열 라이선스의 하나임. 대표적인 SW : Node.js, jQuery, Ruby on Rails, X11

BSD(Berkeley Software Distribution) License
매우 자유로운 라이선스 / 다음 사항만 준수하면 변경 또는 배포에 문제가 없음 => 소스코드에 포함된 저작권 관련 문구들의 보존해야 한다. BSD 라이선스 SW의 사용으로 인해 발생하는
위험 또는 손해를 저작자에게 물을 수 없다. 대표적인 SW: Nginx 웹서버

Apache License
Apache Software Foundation에서 생산하는 SW에 적용하는 라이선스 / Apache License 소스코드를 수정해서 배포하려면 Apache License 임과 Apache Software Foundation의
소프트웨어임을 반드시 밝혀야 한다.





CH3-1 Basic Commands

커널(Kernel)
운영체제의 핵심기능을 담당하는 부분. CPU, 메모리, 디스크, 네트워크 등 하드웨어와 프로세스를 관리

추가 프로그램(Supplied programs)
문서작성, 게임, 웹브라우저 등 다양한 용도에 사용되는 응용프로그램들

쉘(Shell)
사용자가 텍스트 형식으로 명령을 입력할 수 있는 인터페이스를 제공하고, 주어진 명령을 실행하며, 명령의 실행 결과를 화면을 통해 보여주는 응용프로그램

X윈도우 시스템
Linux 운영체제에서 GUI를 사용할 수 있게 해주는 응용프로그램 / KDE나 GNOME은 X 윈도우를 기반으로 제작된 데스크탑 환경

man 명령
주어진 명령에 대한 manual page를 보여주는 명령 ex> man ls

. => 현재 디렉토리 / .. => 상위 디렉토리 / pwd => 현재 디렉토리를 알려준다
$HOME => 홈 디렉토리(~)  /  cd - => 이전 디렉토리로 변경
mkdir => 디렉토리 생성(-p 달면 부모 디렉토리 포함해 생성) / rmdir => 디렉토리 삭제

제어키 
CTRL-C => 현재 실행중인 명령을 멈춘다 / CTRL-D => 입력의 종료 / CTRL-\ => 현재 실행중인 명령을 멈춘다 / CTRL-S => 스크린으로의 출력을 멈춘다
CTRL-Q => 스크린 출력을 재개한다 / DEL 또는 CTRL-? => 바로 이전 문자를 삭제 / CTRL-U => 명령행 전체를 삭제 / CTRL-Z => 현재 실행중인 명령을 잠시 멈춤






CH3-2 File Commands
Linux의 파일명은 대소문자를 구분 linux.txt 와 Linux.txt는 다른파일 
Linux에서는 모든 것은 파일로 간주하여 처리할 수 있음

파일 관리 명령
file => 파일의 종류를 알려준다
touchg => 파일의 시간속성을 변경한다.(존재하지 않는 파일에 대해서는 비어 있는 파일을 생성한다)
rm => 파일을 삭제 (-i => 각 파일에 대해 대화형으로 사용자에게 묻고 파일 삭제 / -rf => -r은 하위 디렉토리들도 삭제 , -f는 디렉토리 내에 파일이 존재하더라도 삭제)
cp => 파일 복사(-r => 재귀적으로 하위 디렉토리들 및 그 안의 파일들도 복사 / -i => 대화형으로 복사를 실행)
mv => 파일 이동(이름바꿔서 이동가능)
rename => 정규식을 사용하여 파일 이름 변경 가능
more , less => 파일의 내용을 화면 크기 단위로 보여준다 , 스페이스 키를 이용하여 다음 화면으로 전환(less는 화살표를 사용하여 내용을 볼 수도 있다)






CH3-3 Linux File System Hierarchy

Linux의 파일 시스템
'/'로 표시되는 루트 디렉토리를 최상위로 하는 트리 형의 계층적 구조를 가지는 파일시스템을 사용(FHS에 따른 계층구조)
디렉토리 자체도 파일의 한 종류임에 주의 / 리눅스는 시스템의 모든 것이 파일 형태로 접근 가능
디렉토리 구조 및 기능은 배포판 별로 달라질 수 있으며 해당 시스템의 파일시스템 계층 구조에 대한 정확한 정보는 'man hier'명령을 통해 알 수 있다.

바이너리 디렉토리들
실행 가능한 바이너리(기계어 명령들)파일들을 유지하는 디렉토리들
/bin => 모든 사용자들이 사용하는 바이너리 파일(명령)들을 포함
/sbin => 시스템 설정에 사용하는 바이너리 파일들을 주로 포함 / 프로그램의 실행을 위해서는 root권한이 필요한 경우가 많음
/lib => 바이너리 파일들이 사용하는 라이브러리 파일들이 존재 /lib/modules/$kernel-version 디렉토리는 Linux kernel 관련 모듈들을 포함
/opt => 선택적인(optional) 소프트웨어들이 주로 설치되는 곳 / 패키지 별로 /opt/$packagename 형식의 서브디렉토리를 사용함

시스템 설정 관련 디렉토리들
/boot => 컴퓨터를 부팅하기 위한 파일들을 포함 / /boot/grub 디렉토리에는 부팅시 사용되는 GRUB관련 설정이 포함됨
/etc => 시스템 설정관련 파일들을 포함 / /etc/*conf => 응용프로그램, 데몬 또는 프로토콜 관련 설정 파일들 / /etc/init.d/ => 데몬 프로그램의 시작과 종료를 위한 스크립트 파일들을 포함
/etc/X11 => X윈도우 시스템(Linux/Unix의 윈도우 시스템) 관련 파일 / /etc/skel => 사용자 홈ㄷ기렉토리에 포함되는 기본 파일들을 모은 디렉토리, 새로운 사용자를 생성하면
/etc/skel 내의 파일이 새 사용자의 홈디렉토리에 복사됨 / /etc/sysconfig/

데이터 디렉토리들
/home => 각 사용자의 홈디렉토리가 /home의 서브디렉토리로 생성됨
/root => root 사용자의 홈디렉토리
/srv => cvs,rsync,ftp,www 관련 데이터 디렉토리
/media => 탈부착이 가능한 저장장치를 위한 디렉토리 / /media/cdrom, /media/cdrom0, /media/usbdisk 서브디렉토리
/mnt => 임시로 사용되는 파일시스템의 마운트 위치
/tmp => 임시로 사용하는 파일들을 저장하기 위한 디렉토리이며 시스템이 재시동하면 자동 삭제되므로 오랫동안 보관해야하는 파일들은 여기에 두면 안됨

메모리 상에 만 존재하는 디렉토리들
저장장치에 기록되지 않고 시스템 동작시에만 존재하는 디렉토리들
/dev => 커널에 의해 인식된 하드웨어들을 파일처럼 보여주는 디렉토리 / 물리적인 하드웨어 장치의 유형별로 파일의 이름이 부여됨
SATA,SCSI,USB 장치들은 /dev/sda, /dev/sda1, /dev/sdb 등 IDE, ATAPI 장치들은 /dev/hda, /dev/hda1, /dev/hda2 등
/dev/tty 또는 /dev/pts => GUL상의 터미널 또는 콘솔에게 부여되는 파일들 
/dev/null => 이 파일에 추가되는 모든 데이터는 곧바로 사라짐. / 명령의 출력물을 없애고자 할 때 주로 이 파일에 출력을 redirect함
/proc => 동작중인 CPU 및 프로세스 관련 정보를 보여주는 디렉토리 / 파일들의 크니는 0이나 CAT 명령을 수행하면 관련된 정보를 보여줌 (cat /proc/cpuinfo)
/proc/interrupts파일 =>CPU별로 인터럽트 상태를 보여줌 / /proc/kcore 파일 => 물리적인 메모리를 파일로 보여줌
/sys => 동작중인 리눅스 Kernel 관련 정보를 파일 형태로 제공하는 디렉토리

/usr 디렉토리
usr은 Unix System Resources를 의미이며 리눅스의 공유 데이터 파일들을 주로 포함
서브 디렉토리들
/usr/bin => 리눅스 명령에 해당하는 프로그램들 / /usr/include/ => C프로그램을 위한 헤더 파일들 / /usr/lib/ => 라이브러리 파일들
/usr/local/ => 전통적으로 Linux(또는 Unix) 운영체제의 일부가 아닌 자체적으로 개발한 프로그램들을 설치하던 디렉토리
/usr/share/ => 특정 하드웨어와 관계없는 읽기 전용의 파일들이 위치 / /usr/src/ => 커널 소스 파일들이 위치함

/var 디렉토리
다양한 크기의 log,cache,spool 데이터 파일들이 위치하는 곳, 프로그램별로 서브디렉토리를 가지는 경우가 흔하다
/var/log/ => 프로그램 동작 시 로그 메세지들을 저장하는 곳 / Debian (Ubuntu 포함)계열은 /var/log/syslog 파일에 시스템 로그가 저장
/var/spool/ => 프린터 또는 Email과 같이 비동기 작업을 위해 데이터 파일을 임시 저장하는 디렉토리
/var/lib/ => 응용프로그램별로 자신의 상태 정보를 기록하는 용도로 사용하는 디렉토리
/var/lock/ => 파일에 대한 동시접근을 제어하기 위한 잠금 파일들이 위치하는 디렉토리





CH4
쉘 확장
사용자가 입력한 명령행을 Linux의 쉘이 해석하는 과정

bash
Linux에서 가장 널리 사용되는 쉘 (기존 sh에 csh과 ksh의 장점을 추가)

명령인자
echo hello world => helloworld로 출력(-e => 인자 내의 Escape Character를 해석하는 옵션(\n 같은거 해석))
인자들의 공백문자들은 모두 제거 / 따옴표 또는 쌍또옴표로 묶인 문자열은 단일한 인자로 처리되며 내부의 공백 문자도 그대로 유지된다

명령의 종류
빌트인 명령 => 쉘이 자체적으로 해석하는 명령
외부 명령 => /bin 또는 /sbin과 같은 파일 시스템에 존재하는 바이너리 파일에 해당하는 명령. / 환경변수 PATH에 등록된 순서에 따라 외부 명령을 찾는다
type 명령을 통해 명령의 종류 확인 가능 type cd등
이름이 동일한 명령의 경우에는 내부 명령이 외부 명령에 우선하여 실행된다. type -a echo # echo 명령의 종류를 모두 나열 / /bin/echo "Hello World!" => 외부 명령
which 명령을 사용하면 입력된 외부 명령에 해당하는 바이너리 파일의 위치를 알려준다

쉘 확장 과정 보기
쉘 확장 과정을 표시하려면 'set-x'입력 끄려면 +x

작업 제어 연산자
다수의 명령으로 이루어진 작업을 제어하는 연산자
";" => 왼편 -> 오른편의 순서로 명령을 차례로 수행
"&" => 쉘은 주어진 명령을 background로 실행하고 그것이 종료할 때까지 기다리지 않음 / 대신 쉘은 다음 명ㄹ령의 입력을 대기 ex->sleep 20 &
"$?"=> 이전 명령의 종료 코드를 반환한다. Linux명령은 성공적으로 종료하면 0을 반환하고 그렇지않으면 0이 아닌 값을 반환한다.
"&&"=> 논리곱으로 해석 왼편 명령이 성공적으로 종료하면 오른편 명령을 계속해서 실행
"||"=> 논리합으로 해석 왼편 명령이 실패할 때만 오른편 명령을 실행
"#" => 쉘 주석을 나타내며 쉘이 해석하지 않는다
"\" => Escape 문자
"명령행 끝의 \" => 명령행이 다음 행으로 계속 이어짐을 나타낸다

쉘 변수
대소문자를 구분함
"$" => 쉘에서 쌍따옴표를 사용하면 그 안의 스트링을 쉘이 해석함 ex-> echo "we live in $city" (but 따옴표는 그 내부를 해석하지 않음)
모든 변수들의 값을 확인하려면 set 명령을 사용 변수를 삭제하려면 unset 명령을 사용

주요 변수들
HOSTNAME => 호스트 컴퓨터의 이름 / USER => 현재 사용자의 이름 / UID => 현재 사용자의 사용자 식별번호 / SHELL => 현재 사용중인 쉘 / HOME => 현재 사용자의 홈 디렉토리
PS1 => 쉘 프롬프트 형태를 지정 / PATH => 쉘 명령에 해당하는 프로그램을 찾는 디렉토리의 순서

변수 사용
export => 주어진 변수를 자식 쉘에 전달되도록 설정한다 / env => 인자가 없으면 export된 변수들을 보여준다 , 명령을 인자로 주면 주어진 환경으로 실행(-i는 export된 것들을 모두 취소)

변수의 사용
${변수명} 형식으로! / 정의되지 않은 변수를 접근하면 아무 것도 출력되지 않는다 / 에러 메세지를 발생시키려면, 'set-u'를 사용

쉘 임베딩
명령행에서 새로운 쉘을 실행시킬 수 있음 => $()를 사용하는 방법 ,백틱(``)을 사용하는 방법

이전 쉘 명령
!! => 직전 명령을 다시 실행 / !pattern => pattern에 매칭되는 이전 명령을 다시 실행 / history => 현재까지 사용한 명령들을 표시함,공백을 먼저 입력하고 명령을 사용하면 history에 저장되지 않는다
!번호 => 이전 명령들 중에서 번호에 해당하는 명령을 다시 실행

파일 이름 확장
'*' => 글자가 없거나 하나이상의 임의의 글자를 나타냄 / '?' => 임의의 한 글자를 나타냄

문자패턴
[]는 대괄호 사이에 있는 임의의 문자에 해당하는 것을 의미 ex-> ls File[A5] => A나 5중 하나! 
[a-z],[A-Z],[0-9] => 여러개의 문자 또는 숫자를 간략히 표시(a~z까지 한개 이런식) / [!문자] => 문자가 들어있지 않음을 의미

파일 이름 확장 막기 => \*, '*', "*" => *이 모든 글자로 해석되는 것을 막는다






CH5-1
표준 입출력
stdin => 표준 입력장치로써 명령에 데이터를 공급한다. 디폴트는 키보드
sdtout => 표준 출력장치로써 명령의 출력이 전달된다. 디폴트는 터미널 화면
stderr => 에러 메세지가 출력되는 장치로써 디폴트는 터미널 화면

출력 리다이렉션
">"기호를 사용하여 출력 스트림을 변경할 수 있음 ex-> > 새 파일 생성하고 쓴다 두번째 > 덮어쓴다 >> 기존 내용에 추가한다 / cat > names.txt (names.txt파일에 입력)

에러 리다이렉션
"2>"를 사용하여 에러 스트림을 변경 ex-> find / > allfiles.txt 2>error.txt => 파일 목록과 에러 메시지를 구분하여 저장
find / > allfiles.txt 2>&1 => 2>&1은 stdout과 stderr를 같은 스트림으로 보낸다
find / 2>&1 > allfiles.txt => stderr(2)가 stdout(1,이 경우 화면)로 먼저 리다이렉트되고, stdout은 나중에 파일로 리다이렉트 된다.

파이프(|)
이전 명령의 출력을 다음 명령의 입력으로 전달한다

입력 리다이렉션
"<(또는 0<)"를 사용하여 표준 입력장치를 변경

주요 필터 명령
cat
tee => 표준입력으로 전돨된 데이터를 파일과 표준출력 양쪽으로 전달 / grep => 주어진 문자열을 포함하는 라인을 찾는다 / tr => 문자단위로 치환한다
wc => 단어,라인수,문자수를 계산한다 / sort => 입력 데이터를 정렬한다 / uniq => 입력 데이터에서 중복을 제거한다 / sed => 정규식을 사용하여 치환한다

find => 주어진 조건과 일치하는 파일을 검색하기 위한 명령
find [-H][-L][-P][-D debug][starting points][expression]
H,L,P는 symbolic link를 처리하는 옵션 / -D : 디버깅을 위해 find의 처리과정을 보여주는 옵션 / -Olevel : find 실행요율을 높이는 최적화 수준을 설정
starting points => 검색 시작 위치(디렉토리),디폴트는 현재 디렉토리
expression => 조건식은 test와 act ion을 -not, -a(-and), -o(-or)로 연결한 것, 디폴트는 -print
find 실행 예 10page

locate
모든 디렉토리에서 주어진 패턴에 해당하는 파일을 찾음(시스템에 구축되어 있는 인덱스를 사용하기 떄문에 새로 추가된 파일들이 검색 대상에서 누락될 수 있음)(updatedb 명령으로 해결)
locate [option] ...[pattern]...
-A => 주어진 모든 패턴을 만족시키는 것만 찾음 / -b => basename(디렉토리 부분을 제거한 파일명)이 패턴과 일치하는 것을 찾음
-c => 파일 개수 출력 / -e => 실행시 실제로 존재하는 파일명만 출력 / -i => 대소문자를 가리지 않고 패턴을 검색

sleep => 주어진 시간(초 단위) 동안 sleep 모드로 대기함 / time => 뒤에 오는 명령을 실행하는데 소요된 시간을 출력함

gzip => 파일을 압축하고 압축된 파일은 .gz 확장자가 추가됨 gzip [OPTION]...[FILE]... 
-d => 압축을 해제 / -l => 압축된 파일들의 목록을 출력 / -q => 경고 메세지를 출력하지 않음 / -1 => 빠른 압축, 압축률을 낮아짐 / -9 => 압축율을 최대로 높임, 소요시간이 늘어날 수 있음
gunzip => 압축을 해제 zcat = gunzip -c => 압축된 파일의 내용을 화면에 출력
bzip2/bunzip2(bzcat,bzmore)는 gzip/gunzip보다 더 높은 압축율 but 압축에 걸리는 시간 증가





CH5-2
gedit => GNU GPL 라이선스의 GUI기반 텍스트 편집기 / UBUNTU 데스크탑의 공식 텍스트 편집기 / GNOME 데스크탑 환경용으로 개발됨 / 단순한 디자인에 비해 강력한 텍스트 편집 기능
vi Editor => 리눅스 시스템에서 간결하게 텍스트 편집가능 

vi 에디터의 동작 모드 "esc시 명령 모드로"
명령 모드 => 프로그램 시작시 기본 모드 / 커서 이동,복사 및 다른 모드로 전환할 수 있는 모드 ": => 명령행 모드로" , "zz => 프로그램 종료"
명령행 모드 => 문자열 검색, 치환, 저장, 종료 등의 명령을 수행할 수 있는 모드 ":q,:q!,wq! => 프로그램 종료"
입력 모드 => 키보드 입력이 파일의 텍스트로 입력되는 모드 "a,A,i,I => 입력 모드로"
비주얼 모드 => 문자,라인,블록 단위로 텍스트를 선택하는 모드 "v,V,ctrl-v => 비주얼 모드로"

vi [options][new or existing file name] -R => 읽기 전용 / -r => 파일 복구 후 편집

커서 이동 
명령 모드에서는 i,j,k,l / 입력모드에서는 alt-i,j,k,l / hjkl기본
자주사용되는 명령 8PAGE

정규식
특정한 패턴의 문자열 집합을 나타내는 식
쉘(bash), vi, grep, find, sed를 포함한 다양한 리눅스 프로그램들에서 문자열 패턴을 검색하기 위해 사용됨
BRE(디폴트) / ERE / PRCE

BRE의 예
"."=> 모든 문자 / "^"=> 텍스트의 시작 위치 / "$"=> 텍스트의 끝 / "\" => ESCAPE 문자 / "\(\) => 정규식을 그룹핑 "\|" => 정규식을 OR 관계로 묶음
\{n\} => 앞 문자가 n번 나타남 / \{n,m\} => 앞 문자가 n번 이상, m번 미만 나타남 / \{n,\} => 앞 문자가 n번 이상 나타남 / \+ => 앞 문자가 한번 이상 나타남
\? => 앞 문자가 나타나지 않거나 한번만 나타남 / * => 앞 문자가 없거나 한번 이상 나타남 
ex-> grep '^IT*'*.c => .c로 끝나는 파일들에서 IT로 시작하는 텍스트 라인을 찾는다
grep 'IT$'* =>IT로 끝나는 텍스트 라인을 찾는다
grep 'p\{2\}'* => 모든 파일에서 pp가 포함된 텍스트 라인을 찾는다

ERE는 BRE에서 \가 없어진 형식?
grep => 파일에서 정규식으로 표현된 패턴에 해당하는 라인을 출력한다
grep [OPTIONS]PATTERN[FILE...] => 파일이 주어지지 않으면 stdin에서 입력, -r의 경우에는 재귀적으로 디렉토리를 찾아가며 실행
egrep = grep-E / egrep은 ERE사용
일반적으로는 ERE가 BRE보다 더 많은 기능, GNU 프로그램들은 BRE와 ERE의 표기형식에 차이가 있을 뿐 기능의 수준은 동일하다
fgrep = grep -F , 패턴을 정규식으로 해석하지 않음
rgrep = grep -r , 재귀적으로 디렉토리들을 탐색

grep u names.txt => names.txt에서 u를 포함한 행 출력

문자열 치환
rename 's/{pattern}/{string}/[flags]' => pattern을 찾아서 string으로 대치함
flags
i => 대소문자를 가리지 않음 / g => {pattern}이 나타날 때마다 치환을 수행,g가 생략된 경우 1번만 실행

sed => 스트림 에디터파일을 데이터의 흐름으로 보고 조작할 수 있는 기능을 제공

vi
문자열 패턴 검색
/{pattern} => 전방향 검색 / ?{pattern} => 역방향 검색 / n=> 다음 매치된 곳으로 이동

문자열의 치환
{range}s/{pattern}/{string}/{flags} => {range} : 범위 %(모든 라인), k,l(k에서 l라인, $는 마지막 라인), 없으면 현재 라인에서만 치환
ex -> 4,8s/foo/bar/g => 4번째 라인부터 8번째 라인까지 문자열 foo를 bar로 여러번 치환가능






CH6
whoami => 현재 사용자를 알려줌 / who => 현재 시스템에 로그인되어 있는 사용자들에 대한 정보 보여줌 
w => 현재 시스템의 워코르도와 로그인한 사용자들이 수행중인 데스크를 보여준다 / id => 현재 사용자에 대한 사용자ID, 기본 그룹ID, 소속 그룹리스트를 보여줌

su => 다른 사용자 ID로 새로운 쉘을 시작하는 명령이다 / '-'옵션은 USER 로그인 환경을 그대로 적용하려는 경우 => PATH 디폴트,기타 초기화, 현재디렉토리 변경된다

sudo => 다른 사용자로 명령을 수행하는 프로그램
sudo su- => root 사용자로 쉘을 사용하기 위한 명령

/etc/passwd => Linux 사용자에 대한 정보를 유지하는 파일 ":"문자로 각 컬럼의 값을 구분함 각 컬럼은 사용자이름/x/사용자id(숫자)/기본 그룹id/사용자에대한설명/홈디렉토리/로그인쉘

사용자의 생성 => /usr/sbin/useradd or /usr/sbin/adduser
사용자의 제거 => /usr/sbin/userdel or /usr/sbin/deluser
사용자 정보의 변경 => /usr/sbin/usermod
/etc/default/useradd => 새로 생성되는 사용자에 대한 디폴트 설정값을 보관
/etc/skel/ => 새로 생성된 사용자의 홈디렉토리에 복사될 파일들이 위치함
chsh => 자신의 로그인쉘을 변경하는 명령

암호의 변경
passwd [user name] => 인자로 주어진 사용자에 대한 암호를 변경함
/etc/shadow => 각 사용자에 대한 암호를 관리하는 파일

/etc/login.defs => 암호를 비롯한 로그인 관련 디폴트 값들을 정의하고 있음 / 'PASS_'로 시작하는 값들은 암호 설정과 관련한 디폴트 값을 가짐
/etc/passwd 파일의 직접적인 변경 => vi보다는 vipw명령을 사용(locking에 유리)

그룹관리
그룹은 사용자의 집단을 구분하여 데이터 공유 및 권한 관리를 위해 사용 
groupadd => 그룹 추가 / groups => 그룹 목록 출력 / groupdel => 그룹제거 / gpasswd => 그룹관리 명령 
/etc/group => 그룹 정보를 유지하는 파일 / /etc/gshadow => 그룹 관리자에 대한 정보를 유지





CH7 패키지 및 시스템 관리
apt purge => 패키지와 관련 설정 정보를 모두 제거

Linux 부팅 과정
BIOS POST -> GRUB 실행(리눅스를 비롯한 다양한 OS의 Kernel을 찾아서 메모리에 적재하고 실행) -> Kernel 실행(메모리에 kernel구조를 형성하고 systemd 프로세스를 가동) 
-> systemd 프로세스 동작(systemd:처음 실행되는 프로세스이며 추후 모든 프로세스를 생서하는 부모 프로세스)

Linux 런레벨
런레벨은 리눅스 시스템의 동작 모드를 의미
런레벨 3(CLI) or 5(GUI)가 디폴트 / 런레벨 6 => Reboot

Linux 종료 
shutdown(-c => 예정된 종료 취소. -r => 리부트 , -k=>가짜)
reboot => 즉시 재부팅(-p => 시스템 종료 , -f 강제로 재부팅)
dmesg => 부팅이후 출력된 모든 커널 메세지를 출력함
vmstat => 동작중인 프로세스들과 메모리 상태, 입출력 등에 대한 정보를 알려준다
mpstat -P ALL 1 => 프로세스 관련 정보를 출력함
pidstat 1 => 각 프로세스에 대한 상태정보를 출력한다 / top의 프로세스 정보와 유사
Top => 실행중인 프로세스들에 대한 정보를 보여준다
iostat -xz 1 => 전체 CPU 사용률 및 각 장치 및 파티션별 입출력 상황을 보여준다
free => 시스템 메모리의 상태에 대해 알려줌
sar -n DEV 1 => 네트워크 인터페이스에 대한 상태정보를 보여줌
sar -n TCP,ETCP 1 => TCP 프로토콜 관점에서 네트워크 상태정보를 보여줌





CH8
파일의 소유권
리눅스의 모든 파일에는 소유자와 소유그룹이 부여됨
소유그룹의 변경 => chgrp
소유자의 변경 => chown
파일 유형(파일 정보의 첫 문자로 알아냄) => -:일반 파일 d:디렉토리 |:심볼릭 링크 p:이름이 부여된 파이프 b:블록 장치 c:문자 장치 s:소켓
파일 접근 권한 _ _ _ _ _ _ _ _ _ 각 3개씩 사용자,그룹,기타사용자로 표현 ex-> rwx_wx_wx
r: 파일 - 파일의 내용을 읽을 수 있음 / 디렉토리 - 디렉토리의 내용을 읽을 수 있음
w: 파일 - 파일에 내용을 쓸 수 있음   / 디렉토리 - 디렉토리 내에 파일을 생성할 수 있음
x: 파일 - 파일을 실행할 수 있음      / 디렉토리 - 디렉토리 내로 진입 가능

chmod (-v:실행중 상세한 메세지를 출력 , -R:파일과 디렉토리들을 재귀적으로 찾아가면서 명령을 실행)
chmod g-r file1.txt 그룹에 대한 읽기 권한을 제거 / chmod u=rw file1.txt 소유자에 대해 읽기 쓰기 권한부여 
a(디폴트) => all()
chmod 777 => rwxrwxrwx! 팔진수생각

umask => 파일(디렉토리)이 생성될 때, 파일접근 권한 중 부여하지 말아야 할 것을 나타냄
umask 0(팔진수임을 나타냄)022 => chmod u=rwx,g=rx,o=rx

mkdir -m => 디렉토리를 생성하면서 접근권한을 같이 부여할 수 있음 ex-> mkdir -m 775 public
파일 복사를 하면서 복사본 파일의 변경시간을 원본과 동일하게 유지 => cp -p

CH10
gcc(-c:컴파일만 수행, -o <file>: 실행 결과를 <file>이름으로 저장, -g:디버그용 코드 생성, -O:코드 최적화 수준 지정, -I:표준 헤더파일 이외의 헤더파일들이 있는 디렉토리들을 지정
,-l:링크할 라이브러리를 지정, -Wall:더욱 많은 경오 메세지 출력)

라이브러리 사용하기
헤더파일 -> /usr/include/에 보통 있음 / 라이브러리 -> /usr/share/doc/<package>혹은 웹에서, 혹은 헤더 파일에서!
라이브러리를 사용하는 프로그램 컴파일 => 가장쉬운방법:pkg-config ex-> gcc -o test test.c $(pkg-config--cflags-libs)

디버깅 => gdb
gdb는 텍스트 기반이다. 쉘과 유사한 command-line 인터페이스를 제공한다.
명령어 : break(b):브레이크 포인트 설정 / print(p): 변수의 값을 프린트 / c:다음 브레이크 포인트까지 실행 계속 / next(n),step(s): 한 줄 실행
backtrace(bt):함수 호출 스택 디스플레이 / run:프로그램을 실행 / start: 디버깅 실행

서로 다른 파일 간의 변수의 공유
변수의 선언과 정의의 구분
선언: 컴파일러에게 변수의 존재를 알려줌
정의: 실제로 메모리를 할당
변수는 여러 번 선언될 수 있다. 하지만 정의는 한번만 해야 한다.
선언과 정의를 동시에 하는 방법 : int i;
키워드 extern을 이용하여 변수를 정의하지 않고 선언만 하는 방법 : extern int i;, extern int a[];

중복된 헤더 파일이 항상 오류인 것은 아니다. 매크로 정의, 함수 프로토타입, 외부(extern) 변수의 선언은 여러 번 중복되어도 상관 없다.
하지만 타입 정의가 중복되는 것은 컴파일러 오류를 야기한다.

헤더 파일의 중복 방지
#ifndef - #endif 사용 or #pragma once 사용

make 와 Makefile
의존성: 프로그램 빌드에는 순서가 있음
Makefile => 파일들간의 의존성을 기술하는 파일 / 프로그램을 빌드하는 방법을 정의
유틸리티 프로그램 make => Makefile을 읽어서 지정된 방법으로 프로그램을 빌드해주는 프로그램

CTAGS => 프로그램 소스 파일에서 각종 심볼(Symbol, 변수, 함수, 매크로 등)들에 대한 Tag File를 구성하여, 심볼들을 정의한 위치와 참조관계를 빠르게 탐색할 수 있는 Software Tool
대규모의 소스 코드를 분석하기에 적합 / BSD 라이센스이며 다양한 프로그래밍 언어를 지원 

CTAGS 사용법
형식 : ctags <파일 리스트> 또는 ctags -R => 현재 디렉토리 및 모든 하위 디렉토리의 파일들에 대해 tag를 생성
vi => vi ~/.vimrc 명령으로 vimrc 파일을 열고 set tags=./tags => vi 명령으로 소스 파일을 읽고 ctags 명령을 사용 1.tj<심볼> 또는 심볼에서 '^]'를 누름: 해당 심볼이 정의된 위치로 이동
2. po 또는 ^t: 이전 위치로 이동


CH11
버전관리시스템 => 파일 및 자원들에 대한 변경사항을 추적하고 관리하는 소프트웨어
(CVS,Subversion(SVN),Git,Monotone,BitKeeper,Perforce)

저장소는 모든 사용자들이 공유하는 것과 사용자 개인만 사용하는 것으로 구분됨
Git과 Mercurial은 개인저장소가 있으나 CVS, SVN은 없음
작업중인 디렉토리의 파일은 저장소에 '추가'되어야 버전관리시스템의 관리 대상이 된다.
저장소에는 소스 파일,빌드 파일, 아이콘 및 GUI디자인 등의 자원 파일들 있음
오브젝트 파일과 실행파일은 저장소에 x

Git을 사용하기 위해서 Github를 사용 안해도 됨

git help <verb> => 무슨명령인지! (git <verb> --help / man git-<verb>)

기존 SUV등은 불편해서 Git을 Linux 개발자 커뮤니티에서 탄생(2005년 Linus Torvalds(Linux curnel을 91년에 최초로 만든사람)가 개발 시작)
초기 개발 목적 : 1. 실행속도가 빠를 것 2. 직선형 모델외에 병렬적인 개발 모델도 지원할 것 3. 완전 분산형 구조 4. Linux 프로젝트와 같은 대형 개발 프로젝트에서 사용가능할 것

로컬 저장소의 접근 과정 
working directory => staging area (stage files)
   staging area   => git directory(commit)
   git direcory   => working directory(checkout the project)

git에서 파일의 Lifcyle
untracked(working direcotry에 있고 저장소에 없는 파일) => staged(staging Area) (Add the file)
Staged => Unmodified (Commit(Repository(git directory)에 집어넣기))
Unmodified => untracked (Removed the file)(repository file을 지우기)
Unmodified => Modified (Edit the file)(Repository file -> check out(고침))
Modified => Staged (Stage the file)

Git의 기본 작업흐름
작업디렉토리에서 파일을 변경 -> 스테이지 영역에 변경한 파일들을 추가 -> '커밋(commit)'을 통해 스테이지 영역의 파일들을 Git에 반영(Git 디렉토리 추가)
주의 : Git 디렉토리에 위치한 파일들은 커밋된 것으로 간주. 작업디렉토리에서 변경되어 스테이지 영역에 추가된 파일들은 '스테이지된(staged)' 상태
,작업 디렉토리에서 변경되었으나 아직 스테이지 되지 않은 파일들은 '변경된(modified)' 상태임

커밋시 사용할 사용자이름 과 Email을 설정 git config -- global user.name "Hong kil-Dong" / git config -- global user.email hong@gmail.com
git config --list 로 설정 정보 알 수 있음

git clone <url> [local dir name](여기서 local dir name을 안주면 현재 디렉토리에 복제)
.으로 시작하는 파일들은 ls -al로 봄

push.default 설정x 경고 => git config --global push.default simple로 해결
git config --global core.editor vi => vi로 editor 바꾸기(emacs => emacs로 바꾸기)

git init -> .git 디렉토리 생성
git add eval. 파일들은 '스테이지된(staged)' 상태

Git 명령어
git diff => 스테이지 영역의 파일과 작업디렉토리의 파일에 대한 차이를 비교
git diff --cached => 로컬저장소의 파일과 스테이지된 파일과의 차이 비교
git pull => 원격 저장소에서 파일들을 가져와서 현재가지(branch) 파일들과 합병(merge)함
git push => 원격 저장소에 현재 가지(branch)의 파일들을 합병(merge)함

커밋
커밋할 파일은 반드시 먼저 스테이지되어야 하며 이후 만약 파일이 변경되면 다시 스테이지되어야 함.
스테이지된 파일을 취소 => git reset HEAD -- <file>
작업중인 파일을 이전에 commit한 상태로 돌림 => git restore <file> (2.23 이전버전은 checkout)
직전 commit 작업을 변경할 때 사용. 파일의 추가, 커밋 메세지 변경 => git commit --amend
git commit -m "~~~" => 커밋시에는 모든 스테이지된 파일이 저장소에 기록(사용자의 로컬 저장소에 커밋된다는 것에 주의)
작업디렉토리 내의 변경된 파일을 이전에 커밋된 상태로 되돌리려면 => git checkout -- <file>(현재 디렉토리에 있는 파일을 repository 파일로 대체!)

원격저장소(Remoto Repository)
로컬 저장소가 아닌 네트워크를 통해 접속할 수 있는 저장소(같은 컴퓨터도 가능)
cloning(리무트 저장소와 똑같은거를 내 컴퓨터에 만듦)을 한 경우 remote는 클론닝을 한 URL이 origin이 됨
git remote -v => 원격저장소에 대한 정보 확인
git fetch <remote>(원격저장소이름) => 원격지에는 존재하나 로컬에는 존재하지 않는 파일들을 가져옴
git push <remote>< <branch> => 로컬저장소의 파일들을 원격 저장소에 업로드
git remote show <remote> => 원격저장소에 대한 상세한 정보를 조회
git remote rename <remote> <new-name> => 원격저장소에 대한 이름 변경
git remote remove <remote> => 원격저장소에 대한 참조를 제거

Pull => 원격저장소에서 가장 최신 상태의 파일들을 로컬저장소에 복사
Push => 로컬저장소의 파일을 원격저장소에 복사
일반적인 사용절차
1.변경한 파일들을 Add와 Commit 명령을 사용하여 로컬저장소에 기록 -> 2. pull 명령을 사용하여 원격저장소로부터 파일들의 최신 버전을 로컬저장소에 복사(git pull origin main -> git add calc.c -> git commit -m "~~"(로컬저장소에))
-> 3. 로컬저장소의 파일들을 원격저장소에 Push(git push origin main) / origin = 원격저장소의 URL 또는 Alias / main = 리모트 브랜치의 이름

Git Alias => 예시 : git config --global alias.cm commit -> git cm
태깅 => 저장소의 커밋 위치에 이름을 붙이는 것
git tag v1.4 : v1.4이름의 태그를 현재 위치에 설정
git tag : 태그 리스트를 조회
원격저장소에 태그를 전달 => git push origin v1.5
주석태그(Annotated Tag) => 이름,설명,서명 및 기타 정보를 포함 ex => git tag -a v1.4 -m "my version 1.4"

브랜치(Branch) => 개발 과정에서 기존의 작업과는 분리된 작업(코드)를 수행하기 위한 기능
새로운 브랜치에서 기능 추가 또는 버그 수정 등의 작업을 수행하고, 추후 작업이 완료되면 이전 브랜치와 병합(merge) 수행

브랜치의 생성 => git branch experimental
모든 브랜치들을 리스트할 때 => git branch
experimental 브랜치로 변경할 때 => git checkout experimental (checkout뒤 -b 달면 브랜치의 생성과 체크아웃을 동시에 실행)
만약 두 브랜치에 차이 나는 파일이 있으면 => git checkout main / git merge experimental
브랜치 과정을 보기 => git log --graph
브랜치 삭제 => git branch -d experimental 
git checkout master(원래 브랜치로 변경)

SVN => 중압집중화된 저장소를 채틱 - 중앙의 저장소만 파일의 완벽한 이력정보를 유지
Git => 분산저장소를 사용 - 각각의 저장소는 모두 동등한 기능을 제공함. 속도가 빠르고 파일들이 중복해서 존재하게 됨 / 따라서 브랜치와 병합이 자주 발생함





CH12 Github

Github
가장 거대한 Git 저장소 호스팅 서비스(Git 저장소들의 집합) / 다양한 오픈소스 소프트웨어 및 개발자 들의 소스 코드를 제공
Linux 커널을 포함한 많은 OSS 프로젝트들이 사용하고 있음 / 협업 지원 / 2008년 서비스 시작, 2018년 Microsoft에서 인수
OSS 프로젝트는 무료로 사용가능 그렇지 않은 경우에는 비용을 지불해야 함 / Public으로 설정된 저장소는 모든 기능 사용 가능 (무료 private 저장소는 기능 제약)
마스코트 Octocat

Github 기능
마크다운 방식의 자동렌더링 기능(README 파일 포함) / 이슈추적(issue tracking) 기능(특정 이슈에 대한 진행 상태를 유지) / PULL Request(PR)(코드 검토 및 병합)
/Email 알림 / Github Page 기능(저장소에 대해 정적 웹사이트 제공) / GitHub 전용 애플리케이션(GitHub Desktop,Mobile(윈도우,Mac)(Android,iOS))
/관련사이트(gist.github.com(코드 조각을 공유하는 기능),gitstar-ranking.com(별을 많이 받은 저장소들))

Github를 사용하는 이유
공동 개발을 위한 저장소로 사용 / 체계적인 프로젝트 관리 가능(팀 조직,프로젝트 진행상황,이슈 관리,PULL Request 관리) / 개발자 개인의 포트폴리오가 됨

Git을 사용한 GitHub 접속 
HTTPS(Hyper Text Transfer Protocol Secure) => 2021년 이후에는 단순 ID와 Passwd 접근은 안되며 반드시 '토큰'을 사용해야 함
URL구조 => https://github.com/<user-id>/<repo>.git
SSH(Secure Shell) => Github를 접근하기 위한 공개키/비밀키를 사용하여 접속
URL구조 => git@github.com:<user-id>/<repo>.git






CH13 코드 작성 기초

일반적인 숫자의 사용시 유의할 점
매직넘버를 피하라 / 0과 1은 그냥 사용한다 / 0으로 나누는것은 미연에 방지한다 / 형 변환은 명확하게 수행한다
/ 서로 다른 형을 비교하지 않는다 / 컴파일러의 경고에 주의한다 / (매직넘버 => 소스코드 안에 숫자로 젹혀 있는 것)

정수를 사용할 때 주의할 점
정수의 나눗셈을 검사한다 / 정수 오버플로우를 검사한다 / 중간 결과에서 오버플로우를 검사한다

부동소수점 변수 사용시 주의할 점
서로 크기가 매우 다른 수를 더하거나 빼지 않는다(가장 작은 수부터 더하자) / 동치 비교를 피한다 
/ 라운딩 오류를 예측한다(더 큰 정밀도를 사용 / BCD 표기법을 사용한 변수로 변경 / 정수형을 사용한다)
/ 특정한 데이터 형을 지원하는 언어 또는 라이브러리가 있는지 확인가능

문자와 문자열
매직문자와 매직문자열을 사용하지 않는다 / 하나 모자름 오류를 주의한다 / 사용하고 있는 언어가 유니코드를 어떻게 지원하는지 파악한다
/ 국제화,지역화 전략을 초기에 결정한다 / 만약 알파벳만을 사용할 것이면 ISO 8859를 사용하는 것이 좋다
/ 다중 언어를 지원하려면 Unicode를 사용하라 / 문자열 타입 간에 일관된 변환 전략을 사용한다(프로그램이 다중 문자코드를
지원하는 경우, 내부적으로는 Unicode를 쓰고 I/O에만 코드 변환을 사용)

불린(boolean) 변수
프로그램을 문서화하기 위해 불린 변수를 사용 / 필요하면 고유한 불린 타입을 만든다

열거형의 사용(1)
가독성을 향상시키기 위해서 열거 형을 사용한다 / 신뢰성을 위해서 열거형을 사용한다(컴파일러가 정수 또는 상수를 사용할 때 보다 타입 검사를 강력하게 할 수 있다) 
/ 수정을 용이하게 하기 위해 사용한다(기존 요소의 할당 값 변경 또는 새로운 요소의 추가가 용이하다) / 불린 변수에 대한 대안으로 열거 형을 사용한다(불린 변수는 두 가지만
 표시할 수 있지만 열거 형은 다양한 값을 표현하기에 유리하다) / 타당하지 않는 값을 검사한다

열거형의 사용(2)
반복문의 범위를 지정하기 위해 열거의 처음과 마지막 엔트리를 정의한다(연속되지 않는 경우 주의!) / 열거 형의 첫째를 타당하지 않는 값으로 남겨둔다(대다수의 언어가 열거형의
처음을 0으로 할당하므로 초기화 되지 않은 변수(0일 가능성이 높음)를 잡는데 유리)

명명된 상수
리터럴 대신 명명된 상수를 사용한다 / "확실한" 리터럴 이더라도 명명된 상수를 쓰는 것이 좋다





CH14